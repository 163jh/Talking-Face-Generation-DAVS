from __future__ import print_function, division
import torch.utils.data as data
from torch.utils.data import Dataset, DataLoader
import torch
import Options
import numpy as np
import os
import os.path
import cv2
import scipy.io as scio


matfile_dir = '/home/wyang/Downloads/voxceleb/save/forzh.mat'
root = '/home/wyang/Downloads/voxceleb'
root_dir = os.path.join(root, "align_faces")


def transformation_from_points(points1, scale):
    points = [[70.7450, 112.0000],
              [108.2370, 112.0000],
              # [70.7450, 112.0000],
              # [108.2370, 112.0000],
              [89.4324,  153.5140]]
    points2 = np.array(points) * scale
    points2 = points2.astype(np.float64)
    points1 = points1.astype(np.float64)

    c1 = np.mean(points1, axis=0)
    c2 = np.mean(points2, axis=0)
    points1 -= c1
    points2 -= c2

    s1 = np.std(points1)
    s2 = np.std(points2)
    points1 /= s1
    points2 /= s2

    U, S, Vt = np.linalg.svd(np.matmul(points1.T, points2))
    R = (np.matmul(U, Vt)).T
    sR = (s2 / s1) * R
    T = c2.reshape(2,1) - (s2 / s1) * np.matmul(R, c1.reshape(2,1))
    M = np.concatenate((sR, T), axis=1)
    return M


class ImageLoader(object):
    def __init__(self, mode='train'):
        self.scale = 2
        self.crop_height = 134 * self.scale
        self.crop_width = 134 * self.scale
        self.crop_center_y_offset = 10 * self.scale
        self.output_scale = (260, 260)
        self.ori_scale = (178 * self.scale, 218 * self.scale)
        self.random_x = 0
        self.random_y = 0
        self.flip = 0
        if mode == 'train':
            self.flip = np.random.randint(0, 2)
            self.random_x = np.random.randint(-3, 4)
            self.random_y = np.random.randint(-3, 4)

    def image_loader(self, path, points, p):
        if os.path.exists(path):
            img = cv2.imread(path)
            three_points = np.zeros((3, 2))
            three_points[0] = np.array(points[:2])
            three_points[1] = np.array(points[2:4])
            # three_points[2] = np.array(points[:2])
            # three_points[3] = np.array(points[2:4])
            three_points[2] = np.array([(points[6] + points[8]) / 2, (points[7] + points[9]) / 2])
            three_points.astype(np.float32)
            M = transformation_from_points(three_points, self.scale)
            align_img = cv2.warpAffine(img, M, self.ori_scale, borderValue=[127, 127, 127])
            l = int(round(self.ori_scale[0] / 2 - self.crop_width / 2 + self.random_x))
            r = int(round(self.ori_scale[0] / 2 + self.crop_width / 2 + self.random_x))
            t = int(round(self.ori_scale[1] / 2 - self.crop_height / 2 + self.crop_center_y_offset + self.random_y))
            d = int(round(self.ori_scale[1] / 2 + self.crop_height / 2 + self.crop_center_y_offset + self.random_y))
            align_img2 = align_img[t:d, l:r, :]
            align_img2 = cv2.resize(align_img2, self.output_scale)
            save_dir = os.path.join(root_dir, path[36:50])

            if not os.path.exists(save_dir):
                os.mkdir(save_dir)
            cv2.imwrite(save_dir + "/" + p, align_img2)
            return align_img2
        else:
            raise ("image = 0")


class ImageFolder(data.Dataset):
    """A generic data loader where the images are arranged in this way: ::
    Args:
        matfile_dir  (string): Matfile directory path
        root (string): Root directory path.

    """

    def __init__(self, matfile_dir, mode='train', root=None):
        # classes, class_to_idx = find_classes(root)
        self.root = root
        self.dataset_info = scio.loadmat(matfile_dir)
        self.loader = ImageLoader(mode)

    def __getitem__(self, index):
        """
        Args:
            index (int): Index
        Returns:
            tuple: (image, target) where target is class_index of the target class.
        """
        path = self.dataset_info['list'][index][0][0].encode("ascii")[33:]
        path = path.replace('\\', '/')
        print(path)
        points = self.dataset_info['pts_all'][index].astype(int)
        self.path = os.path.join(self.root, path)
        print(self.path[36:50])
        img = self.loader.image_loader(self.path, points, path[20:])

        return img

    def __len__(self):
        return len(self.dataset_info['list'])



train_videoloader = ImageFolder(matfile_dir=matfile_dir, mode='test', root=root)
train_dataloader = DataLoader(train_videoloader, batch_size=1,
                        shuffle=False, num_workers=1, drop_last=True)
train_file_num = len(train_videoloader)

for step, (train_data) in enumerate(train_dataloader):
    continue